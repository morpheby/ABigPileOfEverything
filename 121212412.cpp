#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>

typedef uint32_t word;

int main() {
   const word a000040 [] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,
      47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127,
      131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199,
      211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283,
      293, 307, 311, 313, 317, 331, 337, 347, 349};
   std::vector<word> h(8);
   
   for(int i = 0; i < h.size(); ++i) {
      double t = sqrt(a000040[i]);
      word r = * (long*) &t;
      h[i] = r;
   }
   
   std::vector<word> k(64);
   
   for(int i = 0; i < h.size(); ++i) {
      double t = pow(a000040[i], -1F/3);
      word r = * (long*) &t;
      h[i] = r;
   }
   
   std::string input;
   std::getline(std::cin, input);
   
   int sz = input.size()*8 + 1,
      realSz = ((size + 64)&(~(word)511));
   
   std::vector<bool> bits(realSz + 64, 0);
   for(int i = 0, j = 0; i < input.size(); ++i) {
      for(int k = 7; k >= 0; --k, ++j) {
         bits[j] = (input[i]>>k) & 1;
      }
   }
   bits[sz-1] = 1;
   
   for(int i = 0; i < 64; ++i) {
      bits[realSz+64] = (input.size() >> (63-i)) & 1;
   }
   
   for(int i = 0; i < bits.size()/512) {
      std::vector<word> w(64);
      
   }
}

Полученную битовую строку разбиваем на части по 512 бит и для каждой части последовательно, начиная с первой, выполняем: {
    Разбиваем текущую часть на слова и размещаем их в массиве w. Расширяем массив w до 64 элементов.
    Проинициализируем новые элементы массива. Для i от 16 до 63 выполняем: {
        s0 = w[i-15] циклично сдвинутому вправо на 7
        s1 = w[i-15] циклично сдвинутому вправо на 18
        s2 = w[i-15] сдвинутому вправо на 3
        s3 = w[i-2] циклично сдвинутому вправо на 17
        s4 = w[i-2] циклично сдвинутому вправо на 19
        s5 = w[i-2] сдвинутому вправо на 10
        s6 = побитовому исключающему "ИЛИ" между s0, s1 и s2.
        s7 = побитовому исключающему "ИЛИ" между s3, s4 и s5.
        w[i] = w[i-16] + s6 + w[i-7] + s7
    }
    Создаем копию массива h и назовем ее f.

    Для i от 0 до 63 выполняем: {
        s0 = f[0] циклично сдвинутому вправо на 2
        s1 = f[0] циклично сдвинутому вправо на 13
        s2 = f[0] циклично сдвинутому вправо на 22
        s3 = побитовое "И" между f[0] и f[1]
        s4 = побитовое "И" между f[0] и f[2]
        s5 = побитовое "И" между f[1] и f[2]
        s6 = f[4] циклично сдвинутому вправо на 6
        s7 = f[4] циклично сдвинутому вправо на 11
        s8 = f[4] циклично сдвинутому вправо на 25
        s9 = побитовое "И" между f[4] и f[5]
        s10 = побитовое "НЕ" с f[4]
        s11 = побитовое "И" между s10 и f[6]
        s12 = побитовому исключающему "ИЛИ" между s0, s1 и s2.
        s13 = побитовому исключающему "ИЛИ" между s3, s4 и s5.
        s14 = побитовому исключающему "ИЛИ" между s6, s7 и s8.
        s15 = побитовому исключающему "ИЛИ" между s9 и s11.
        s16 = s12 + s13
        s17 = f[7] + s14 + s15 + k[i] + w[i]
        f[7] = f[6]
        f[6] = f[5]
        f[5] = f[4]
        f[4] = f[3] + s17
        f[3] = f[2]
        f[2] = f[1]
        f[1] = f[0]
        f[0] = s16 + s17
    }

    К каждому элементу массива h добавляем соответствующий по номеру элемент массива f
}